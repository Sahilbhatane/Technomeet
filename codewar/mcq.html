<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MCQ Round - CodeWar</title>
  <link rel="stylesheet" href="css/codewar.css">
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Round 1: MCQ Quiz</h1>
      <div class="question-header">
        <span class="timer-display" id="timer">30:00</span>
        <span class="question-number">Question <span id="current-q">1</span> of <span id="total-q">-</span></span>
      </div>
    </div>

    <div id="language-selection" style="display: none;">
      <div class="form-container">
        <h2 class="text-center">Select Your Language</h2>
        <p class="text-center" style="color: var(--text-secondary); margin-bottom: 20px;">
          You can change language up to 2 times
        </p>
        <div class="language-selection">
          <div class="language-card" onclick="selectLanguage('c')">
            <h3>C</h3>
          </div>
          <div class="language-card" onclick="selectLanguage('cpp')">
            <h3>C++</h3>
          </div>
          <div class="language-card" onclick="selectLanguage('java')">
            <h3>Java</h3>
          </div>
          <div class="language-card" onclick="selectLanguage('python')">
            <h3>Python</h3>
          </div>
        </div>
        <p id="language-changes" class="text-center" style="color: var(--accent-yellow); margin-top: 20px;"></p>
      </div>
    </div>

    <div id="quiz-container" style="display: none;">
      <!-- Language Control Toolbar - Highly Visible -->
      <div id="language-toolbar" style="background: var(--bg-secondary); padding: 12px 20px; border-radius: 8px; margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; border: 2px solid var(--border-color);">
        <div style="display: flex; align-items: center; gap: 15px;">
          <span style="color: var(--text-secondary);">Current Language:</span>
          <span id="current-lang-display" style="color: var(--accent-cyan); font-weight: bold; font-size: 1.1em; text-transform: uppercase;">Python</span>
        </div>
        <button class="btn btn-secondary" onclick="showLanguageChangeModal()" id="change-lang-btn" style="padding: 8px 20px;">
          üåê Change Language (<span id="lang-changes-remaining">2</span> left)
        </button>
      </div>

      <div class="question-list" id="question-nav"></div>
      
      <div class="question-container">
        <div class="question-header">
          <span class="question-number">Question <span id="q-num">1</span></span>
          <span id="autosave-status" style="color: var(--accent-green); font-size: 0.8em;"></span>
        </div>
        <div class="question-text" id="question-text"></div>
        <div class="code-block" id="question-code" style="display: none;"></div>
        <ul class="options-list" id="options-list"></ul>
      </div>

      <div class="navigation">
        <button class="btn btn-secondary" onclick="previousQuestion()" id="prev-btn">Previous</button>
        <button class="btn" onclick="nextQuestion()" id="next-btn">Next</button>
        <button class="btn btn-danger" onclick="submitQuiz()" id="submit-btn">Submit Quiz</button>
      </div>
    </div>
  </div>

  <!-- Error logging for automated testing -->
  <script src="js/logger.js?v=1"></script>
  <script src="js/utils.js?v=3"></script>
  <script src="js/storage.js?v=4"></script>
  <script src="js/auth.js?v=3"></script>
  <script src="js/timer.js?v=3"></script>
  <script src="js/scoring.js?v=1"></script>
  <script src="js/anti_cheat.js?v=4"></script>
  <script src="js/data.js?v=3"></script>
  <script>
    let questions = [];
    let currentQuestionIndex = 0;
    let answers = {};
    let roundTimer = null;
    let antiCheat = null;
    let isSubmitting = false;  // FIX: Prevent double submission
    let currentLanguage = null;

    // Check authentication and round access
    if (!requireAuth()) {
      // Redirect handled by requireAuth
    } else {
      // FIX: Validate round state
      const currentRound = StorageManager.getCurrentRound();
      if (currentRound === 'completed') {
        window.location.href = 'results.html';
      } else if (currentRound === 'debug' || currentRound === 'ps') {
        // Already past MCQ, allow access for review but warn
        console.log('[MCQ] Round already completed, allowing review');
        initializeQuiz();
      } else {
        initializeQuiz();
      }
    }

    function initializeQuiz() {
      // Verify storage is working
      if (!StorageManager.verifyStorageIntegrity()) {
        // NON-BLOCKING: Using showAlert instead of alert() to prevent focus theft
        // which would trigger anti-cheat false positives
        showAlert('Browser storage is not working. Please enable cookies and try again.', 
          'Storage Error', 'error', () => window.location.href = 'index.html');
        return;
      }
      
      // Initialize anti-cheat
      antiCheat = initAntiCheat(true);

      // Check if language is selected
      const language = StorageManager.getLanguageChoice();
      if (!language) {
        showLanguageSelection();
      } else {
        currentLanguage = language;
        loadQuestions(language);
      }
    }

    function showLanguageSelection() {
      document.getElementById('language-selection').style.display = 'block';
      updateLanguageChangesDisplay();
    }

    function selectLanguage(lang) {
      const changes = StorageManager.getLanguageChanges();
      if (changes >= 2) {
        // NON-BLOCKING: showAlert prevents JS blocking that desynchronizes timers
        showAlert('You have reached the maximum number of language changes (2)', 
          'Limit Reached', 'warning');
        return;
      }

      if (StorageManager.getLanguageChoice() !== lang) {
        StorageManager.incrementLanguageChanges();
        // FIX: Clear question order when language changes
        StorageManager.setMCQQuestionOrder(null);
      }

      StorageManager.setLanguageChoice(lang);
      currentLanguage = lang;
      
      document.querySelectorAll('.language-card').forEach(card => {
        card.classList.remove('selected');
        if (card.querySelector('h3').textContent.toLowerCase().includes(lang)) {
          card.classList.add('selected');
        }
      });

      updateLanguageChangesDisplay();
      setTimeout(() => {
        loadQuestions(lang);
      }, 500);
    }

    function updateLanguageChangesDisplay() {
      const changes = StorageManager.getLanguageChanges();
      const remaining = 2 - changes;
      const msgEl = document.getElementById('language-changes');
      if (remaining > 0) {
        msgEl.textContent = `Language changes remaining: ${remaining}`;
        msgEl.style.color = 'var(--accent-yellow)';
      } else {
        msgEl.textContent = 'No language changes remaining';
        msgEl.style.color = 'var(--accent-red)';
      }
      
      // Update the button in quiz container
      const remainingEl = document.getElementById('lang-changes-remaining');
      const changeLangBtn = document.getElementById('change-lang-btn');
      if (remainingEl) remainingEl.textContent = remaining;
      if (changeLangBtn) {
        if (remaining <= 0) {
          changeLangBtn.disabled = true;
          changeLangBtn.style.opacity = '0.5';
        } else {
          changeLangBtn.disabled = false;
          changeLangBtn.style.opacity = '1';
        }
      }
    }
    
    function showLanguageChangeModal() {
      const changes = StorageManager.getLanguageChanges();
      if (changes >= 2) {
        showAlert('You have reached the maximum number of language changes (2)', 'Limit Reached', 'warning');
        return;
      }
      
      const remaining = 2 - changes - 1;  // After this change
      
      // NON-BLOCKING: Show confirmation modal
      showConfirm(
        `Changing language will load different questions for the new language.\n\n` +
        `‚ö†Ô∏è Your current answers for this language will be saved.\n` +
        `‚è±Ô∏è Your timer will continue (not reset).\n\n` +
        `After this change, you will have ${remaining} language change(s) remaining.\n\n` +
        `Do you want to continue?`,
        () => {
          // User confirmed - show language selection
          executeLanguageChange();
        },
        null,
        {
          title: 'Change Language',
          confirmText: 'Yes, Change Language',
          cancelText: 'Cancel',
          type: 'warning'
        }
      );
    }
    
    function executeLanguageChange() {
      // DON'T stop the timer - it should continue
      // DON'T clear answers - they're saved per language
      
      // Show language selection panel
      document.getElementById('quiz-container').style.display = 'none';
      document.getElementById('language-selection').style.display = 'block';
      updateLanguageChangesDisplay();
      
      // Highlight current language
      document.querySelectorAll('.language-card').forEach(card => {
        card.classList.remove('selected');
        const cardLang = card.querySelector('h3').textContent.toLowerCase();
        if (cardLang === currentLanguage || 
            (currentLanguage === 'cpp' && cardLang === 'c++') ||
            (currentLanguage === 'c' && cardLang === 'c')) {
          card.classList.add('selected');
        }
      });
    }
    
    function updateCurrentLanguageDisplay() {
      const langDisplay = document.getElementById('current-lang-display');
      if (langDisplay && currentLanguage) {
        const displayNames = { c: 'C', cpp: 'C++', java: 'Java', python: 'Python' };
        langDisplay.textContent = displayNames[currentLanguage] || currentLanguage;
      }
    }

    function loadQuestions(language) {
      try {
        // Check if CodeWarData is available
        if (typeof CodeWarData === 'undefined' || !CodeWarData.mcq) {
          // NON-BLOCKING: alert() would pause timers and trigger blur events
          showAlert('Error: Question data not loaded. Please refresh the page.', 
            'Data Error', 'error', () => window.location.reload());
          return;
        }

        const langMap = { c: 'c', cpp: 'cpp', java: 'java', python: 'python' };
        const langKey = langMap[language] || 'c';
        
        // Get questions for selected language
        let langQuestions = CodeWarData.mcq[langKey] || [];
        
        if (langQuestions.length === 0) {
          // NON-BLOCKING: Prevents focus theft that triggers anti-cheat
          showAlert('No questions available for this language', 
            'No Questions', 'warning', () => showLanguageSelection());
          return;
        }
        
        // FIX: Persist question order to prevent reshuffling on refresh
        let savedOrder = StorageManager.getMCQQuestionOrder();
        
        if (savedOrder && savedOrder.length > 0) {
          // Restore saved order
          const questionMap = {};
          langQuestions.forEach(q => { questionMap[q.id] = q; });
          
          questions = savedOrder
            .map(id => questionMap[id])
            .filter(q => q !== undefined);
          
          // If some questions are missing, add them
          if (questions.length < langQuestions.length) {
            const existingIds = new Set(questions.map(q => q.id));
            langQuestions.forEach(q => {
              if (!existingIds.has(q.id)) {
                questions.push(q);
              }
            });
          }
          
          console.log('[MCQ] Restored question order from storage');
        } else {
          // First time - shuffle and save order
          const maxQuestions = Math.min(20, langQuestions.length);
          questions = shuffleArray(langQuestions).slice(0, maxQuestions);
          
          // Save the order
          const orderArray = questions.map(q => q.id);
          StorageManager.setMCQQuestionOrder(orderArray);
          
          console.log('[MCQ] Created new question order');
        }
        
        if (questions.length === 0) {
          // NON-BLOCKING: showAlert doesn't steal focus or pause event loop
          showAlert('Error loading questions. Please try again.', 
            'Loading Error', 'error', () => showLanguageSelection());
          return;
        }
        
        // Load saved answers
        answers = StorageManager.getMCQAnswers();
        
        // Show quiz
        document.getElementById('language-selection').style.display = 'none';
        document.getElementById('quiz-container').style.display = 'block';
        
        // Update language display in toolbar
        updateCurrentLanguageDisplay();
        updateLanguageChangesDisplay();
        
        // Initialize question navigation
        renderQuestionNavigation();
        
        // Start timer (only if not already running)
        // Note: startTimer() will restore from saved timestamp if already started
        if (!roundTimer || !roundTimer._isRunning) {
          startTimer();
        } else {
          // FIX: If timer already exists, update display immediately
          const timeEl = document.getElementById('timer');
          if (timeEl && roundTimer) {
            timeEl.textContent = roundTimer.getFormattedTime();
            const remaining = roundTimer.getRemaining();
            if (remaining <= 300) {
              timeEl.classList.add('timer-warning');
            }
          }
        }
        
        // FIX: Restore current question index if saved, otherwise start at 0
        try {
          const savedQuestionIndex = localStorage.getItem('codewar_mcq_current_question_index');
          const parsedIndex = savedQuestionIndex ? parseInt(savedQuestionIndex, 10) : null;
          const startIndex = (parsedIndex !== null && !isNaN(parsedIndex) && parsedIndex >= 0 && parsedIndex < questions.length) 
            ? parsedIndex 
            : 0;
          
          // Display the restored question (or first question)
          displayQuestion(startIndex);
        } catch (e) {
          console.error('Error restoring question index:', e);
          displayQuestion(0);
        }
      } catch (error) {
        console.error('Error loading questions:', error);
        // NON-BLOCKING: Prevents timer desync during error display
        showAlert('An error occurred while loading questions. Please refresh the page.', 
          'Error', 'error', () => window.location.reload());
      }
    }

    function renderQuestionNavigation() {
      const navEl = document.getElementById('question-nav');
      navEl.innerHTML = '';
      questions.forEach((q, index) => {
        const btn = document.createElement('button');
        btn.className = 'question-number-btn';
        btn.textContent = index + 1;
        btn.onclick = () => displayQuestion(index);
        if (answers[q.id]) {
          btn.classList.add('answered');
        }
        if (index === currentQuestionIndex) {
          btn.classList.add('current');
        }
        navEl.appendChild(btn);
      });
    }

    function displayQuestion(index) {
      if (index < 0 || index >= questions.length) {
        console.error('Invalid question index:', index);
        return;
      }
      
      currentQuestionIndex = index;
      
      // FIX: Save current question index for restoration on refresh
      try {
        localStorage.setItem('codewar_mcq_current_question_index', index.toString());
      } catch (e) {
        console.error('Error saving question index:', e);
      }
      const question = questions[index];
      
      if (!question) {
        console.error('Question not found at index:', index);
        return;
      }
      
      document.getElementById('q-num').textContent = index + 1;
      document.getElementById('current-q').textContent = index + 1;
      document.getElementById('total-q').textContent = questions.length || '-';
      document.getElementById('question-text').textContent = question.question || 'Question not available';
      
      // Show code if available
      const codeEl = document.getElementById('question-code');
      if (question.code && question.code.trim()) {
        codeEl.textContent = question.code;
        codeEl.style.display = 'block';
      } else {
        codeEl.style.display = 'none';
      }
      
      // Display options
      const optionsEl = document.getElementById('options-list');
      optionsEl.innerHTML = '';
      
      if (!question.options || question.options.length === 0) {
        optionsEl.innerHTML = '<li>No options available</li>';
        return;
      }
      
      question.options.forEach((option, optIndex) => {
        const li = document.createElement('li');
        li.className = 'option-item';
        const optionLetter = String.fromCharCode(65 + optIndex);
        
        // Check if this option is selected
        if (answers[question.id] === optionLetter) {
          li.classList.add('selected');
        }
        
        li.innerHTML = `<span class="option-label">${optionLetter})</span> ${option || 'Option not available'}`;
        li.onclick = () => selectOption(question.id, optionLetter);
        optionsEl.appendChild(li);
      });
      
      // Update navigation buttons
      document.getElementById('prev-btn').disabled = index === 0;
      document.getElementById('next-btn').disabled = index === questions.length - 1;
      
      // Update question navigation
      renderQuestionNavigation();
    }

    function selectOption(questionId, option) {
      try {
        if (!questionId || !option) {
          console.error('Invalid questionId or option');
          return;
        }
        answers[questionId] = option;
        
        // Save immediately
        const saved = StorageManager.setMCQAnswer(questionId, option);
        
        // Update autosave status
        const statusEl = document.getElementById('autosave-status');
        if (saved) {
          statusEl.textContent = '‚úì Auto Save Enabled';
          statusEl.style.color = 'var(--accent-green)';
        } else {
          statusEl.textContent = '‚ö† Save failed';
          statusEl.style.color = 'var(--accent-red)';
        }
        
        // Refresh display
        displayQuestion(currentQuestionIndex);
      } catch (error) {
        console.error('Error selecting option:', error);
        // NON-BLOCKING: showToast for transient errors, doesn't interrupt exam
        showToast('Error saving answer. Please try again.', 'error');
      }
    }

    function previousQuestion() {
      if (currentQuestionIndex > 0) {
        displayQuestion(currentQuestionIndex - 1);
      }
    }

    function nextQuestion() {
      if (currentQuestionIndex < questions.length - 1) {
        displayQuestion(currentQuestionIndex + 1);
      }
    }

    function startTimer() {
      roundTimer = new RoundTimer('mcq', ROUND_DURATIONS.mcq);
      roundTimer.start((expired, remaining) => {
        if (expired) {
          submitQuiz(true);  // Auto-submit
        } else {
          const timeEl = document.getElementById('timer');
          timeEl.textContent = roundTimer.getFormattedTime();
          if (remaining <= 300) { // 5 minutes warning
            timeEl.classList.add('timer-warning');
          }
        }
      });
      
      // FIX: Update timer display immediately after starting (especially important on refresh)
      const timeEl = document.getElementById('timer');
      if (timeEl && roundTimer) {
        timeEl.textContent = roundTimer.getFormattedTime();
        const remaining = roundTimer.getRemaining();
        if (remaining <= 300) {
          timeEl.classList.add('timer-warning');
        }
      }
    }

    async function submitQuiz(autoSubmit = false) {
      // FIX: Prevent double submission
      if (isSubmitting) {
        console.log('[MCQ] Submission already in progress');
        return;
      }
      
      // NON-BLOCKING CONFIRMATION: Using showSubmitConfirm instead of confirm()
      // confirm() blocks JS, steals focus, and triggers anti-cheat false positives
      if (!autoSubmit) {
        const answeredCount = Object.keys(answers).length;
        showSubmitConfirm({
          totalQuestions: questions.length,
          answeredCount: answeredCount,
          roundName: 'MCQ Quiz'
        }, () => {
          // User confirmed - proceed with submission
          executeSubmit(false);
        });
        return;  // Wait for user confirmation via modal
      }
      
      // Auto-submit (timer expired)
      executeSubmit(true);
    }
    
    // Actual submission logic (separated for non-blocking flow)
    async function executeSubmit(autoSubmit) {
      isSubmitting = true;
      
      try {
        // Get time info before stopping timer
        const timeRemaining = roundTimer ? roundTimer.getRemaining() : 0;
        const totalTime = ROUND_DURATIONS.mcq * 60;
        const timeUsed = totalTime - timeRemaining;
        
        // Stop timer and anti-cheat
        if (roundTimer) roundTimer.prepareForSubmission();
        if (antiCheat) antiCheat.stop();

        // Show loading state
        const submitBtn = document.getElementById('submit-btn');
        if (submitBtn) {
          submitBtn.disabled = true;
          submitBtn.textContent = 'Submitting...';
        }

        // Validate answers and count correct
        let correct = 0;
        if (questions.length === 0) {
          showAlert('No questions to submit', 'Error', 'error');
          isSubmitting = false;
          return;
        }

        for (const q of questions) {
          if (!q || !q.id) continue;
          const userAnswer = answers[q.id];
          if (userAnswer) {
            try {
              const result = await validateMCQAnswer(q.id, userAnswer, currentLanguage);
              if (result.correct) {
                correct++;
              }
            } catch (e) {
              console.error('Error validating answer for question', q.id, e);
            }
          }
        }

        // Get accumulated penalties for this round
        const penalties = StorageManager.getRoundPenalties() || 0;
        
        // Calculate score using ScoringSystem
        const scoreData = ScoringSystem.calculateRoundScore(
          'mcq', correct, timeRemaining, totalTime, penalties
        );
        
        // Save detailed score data
        ScoringSystem.saveRoundScore('mcq', scoreData, timeUsed);
        
        // Also save legacy format for backwards compatibility
        const percentage = questions.length > 0 ? 
          Math.max(0, Math.min(100, Math.round((correct / questions.length) * 100))) : 0;
        StorageManager.setMCQScore(correct, percentage, questions.length);
        
        // Check elimination threshold
        const eliminationResult = ScoringSystem.checkEliminationThreshold('mcq', scoreData.totalScore);
        
        // Mark navigation as legitimate
        if (typeof markLegitimateNavigation === 'function') {
          markLegitimateNavigation();
        }
        
        if (!eliminationResult.passed && !StorageManager.hasAdminOverride()) {
          // User eliminated - show elimination modal
          ScoringSystem.markEliminated('mcq');
          StorageManager.setCurrentRound('completed');
          
          showEliminationModal({
            round: 'MCQ',
            score: scoreData.totalScore,
            threshold: eliminationResult.threshold,
            percentage: eliminationResult.percentage,
            requiredPercentage: eliminationResult.requiredPercentage,
            message: eliminationResult.message
          });
        } else {
          // User passed - proceed to next round
          StorageManager.setCurrentRound('debug');
          
          if (autoSubmit) {
            showAutoExit('Time expired! Your answers have been submitted automatically.', 
              'index.html', 3);
          } else {
            window.location.href = 'index.html';
          }
        }
      } catch (error) {
        console.error('Error submitting quiz:', error);
        showAlert('An error occurred while submitting. Please try again.', 
          'Submission Error', 'error');
        isSubmitting = false;
        
        const submitBtn = document.getElementById('submit-btn');
        if (submitBtn) {
          submitBtn.disabled = false;
          submitBtn.textContent = 'Submit Quiz';
        }
      }
    }
    
    // Show elimination modal
    function showEliminationModal(data) {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100000;
      `;
      
      modal.innerHTML = `
        <div style="background: var(--bg-secondary); padding: 40px; border-radius: 15px; border: 3px solid var(--accent-red); max-width: 500px; text-align: center;">
          <div style="font-size: 64px; margin-bottom: 20px;">‚ö†Ô∏è</div>
          <h2 style="color: var(--accent-red); margin-bottom: 20px;">Round Not Passed</h2>
          
          <div style="background: var(--bg-primary); padding: 20px; border-radius: 10px; margin: 20px 0;">
            <p style="color: var(--text-secondary); margin-bottom: 10px;">Your ${data.round} Score:</p>
            <div style="font-size: 2.5em; font-weight: bold; color: var(--accent-red);">
              ${data.score.toFixed(1)} points
            </div>
            <p style="color: var(--text-secondary); margin-top: 10px;">(${data.percentage}%)</p>
          </div>
          
          <p style="color: var(--text-secondary); margin: 20px 0;">
            Minimum required: <strong style="color: var(--accent-yellow);">${data.threshold} points (${data.requiredPercentage}%)</strong>
          </p>
          
          <p style="color: var(--text-secondary); font-size: 0.9em; margin-bottom: 25px;">
            Unfortunately, you did not meet the minimum score to advance to the next round.
            Your answers have been saved.
          </p>
          
          <button class="btn btn-danger" onclick="window.location.href='results.html'" style="padding: 15px 40px; font-size: 1.1em;">
            View Results
          </button>
        </div>
      `;
      
      document.body.appendChild(modal);
    }
  </script>
</body>
</html>
